/**
 * LOC-DB Central Component
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class BibliographicEntryApi {

    protected basePath = 'https://localhost';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * Given the _id of a bibliographic entry and the _id of a target, i.e., a cited, bibliographic resource, this service takes care of setting all related properties in a consistent way. More precisely, the following three things happen: 1) The 'status' of the bibliographic entry will be changed to VALID 2) The 'references' property of the bibliographic entry will be set to the _id of the target bibliographic resource 3) The 'cites' property of the parent resource of the entry will be extended with the _id of the target bibliographic reource 
     * @param bibliographicEntryId The _id of the subject bibliographic entry that should point to the target bibliographic resource
     * @param bibliographicResourceId The _id of the target bibliographic resource which the bibliographic entry should point to
     */
    public addTargetBibliographicResource(bibliographicEntryId: string, bibliographicResourceId: string, extraHttpRequestParams?: any): Observable<models.BibliographicResource> {
        return this.addTargetBibliographicResourceWithHttpInfo(bibliographicEntryId, bibliographicResourceId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * creates a bibliographic entry for the given bibliographic resource
     * @param bibliographicResourceId The _id of the bibliographic resource to which the new bibliographic entry should be appended
     * @param bibliographicEntry A bibliographic entry which should be saved
     */
    public create(bibliographicResourceId: string, bibliographicEntry: models.BibliographicEntry, extraHttpRequestParams?: any): Observable<models.BibliographicEntry> {
        return this.createWithHttpInfo(bibliographicResourceId, bibliographicEntry, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Retrieves external br suggestions for a given query string related to a bibliographic entry.
     * @param query The query string for which the suggestions shall be retrieved
     * @param threshold The sring similarity (dice coefficient) between the query string and the title + subtile + contributors above which suggestions shall be retrieved
     */
    public getExternalSuggestionsByQueryString(query: string, threshold?: number, extraHttpRequestParams?: any): Observable<Array<models.BibliographicResource>> {
        return this.getExternalSuggestionsByQueryStringWithHttpInfo(query, threshold, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Retrieves internal br suggestions for a given query string related to a bibliographic entry.
     * @param query The query string for which the suggestions shall be retrieved
     * @param threshold The elastic relevance score for above which entrys shall be retrieved
     */
    public getInternalSuggestionsByQueryString(query: string, threshold?: number, extraHttpRequestParams?: any): Observable<Array<models.BibliographicResource>> {
        return this.getInternalSuggestionsByQueryStringWithHttpInfo(query, threshold, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Retrieves the BEs that are not processed by a librarian yet.
     * @param scanId The Id of the Scan for which the BEs shall be retrieved
     */
    public getToDoBibliographicEntries(scanId?: string, extraHttpRequestParams?: any): Observable<Array<models.BibliographicEntry>> {
        return this.getToDoBibliographicEntriesWithHttpInfo(scanId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Deletes a given bibliographic entry by id.
     * @param id The _id of the bibliographic entry to be deleted.
     */
    public remove(id: string, extraHttpRequestParams?: any): Observable<models.BibliographicEntry> {
        return this.removeWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Given the _id of a bibliographic entry this service clears all properties related to a potential target resource in a consistent way. More precisely, the following three things happen: 1) The 'references' property of the bibliographic entry will be cleared 2) The _id of the old target resource will be removed from teh 'cites' property of the parent resource of the entry 3) The 'status' of the bibliographic entry will be changed to OCR_PROCESSED --> Is this always ok? Note that the old target bibliographic resource will not be deleted. 
     * @param bibliographicEntryId The _id of the subject bibliographic entry that should point to the target bibliographic resource
     */
    public removeTargetBibliographicResource(bibliographicEntryId: string, extraHttpRequestParams?: any): Observable<models.BibliographicResource> {
        return this.removeTargetBibliographicResourceWithHttpInfo(bibliographicEntryId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Updates a given bibliographic entry by id. Note that the status needs to be changed to VALID if this service is called after validation by a librarian. Properties that are not given with the update data are preserved.
     * @param id The _id of the bibliographic entry to be updated.
     * @param bibliographicEntry A bibliographic entry with new values to be updated.
     */
    public update(id: string, bibliographicEntry: models.BibliographicEntry, extraHttpRequestParams?: any): Observable<models.BibliographicEntry> {
        return this.updateWithHttpInfo(id, bibliographicEntry, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * 
     * Given the _id of a bibliographic entry and the _id of a target, i.e., a cited, bibliographic resource, this service takes care of setting all related properties in a consistent way. More precisely, the following three things happen: 1) The &#39;status&#39; of the bibliographic entry will be changed to VALID 2) The &#39;references&#39; property of the bibliographic entry will be set to the _id of the target bibliographic resource 3) The &#39;cites&#39; property of the parent resource of the entry will be extended with the _id of the target bibliographic reource 
     * @param bibliographicEntryId The _id of the subject bibliographic entry that should point to the target bibliographic resource
     * @param bibliographicResourceId The _id of the target bibliographic resource which the bibliographic entry should point to
     */
    public addTargetBibliographicResourceWithHttpInfo(bibliographicEntryId: string, bibliographicResourceId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/addTargetBibliographicResource';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'bibliographicEntryId' is not null or undefined
        if (bibliographicEntryId === null || bibliographicEntryId === undefined) {
            throw new Error('Required parameter bibliographicEntryId was null or undefined when calling addTargetBibliographicResource.');
        }
        // verify required parameter 'bibliographicResourceId' is not null or undefined
        if (bibliographicResourceId === null || bibliographicResourceId === undefined) {
            throw new Error('Required parameter bibliographicResourceId was null or undefined when calling addTargetBibliographicResource.');
        }
        if (bibliographicEntryId !== undefined) {
            queryParameters.set('bibliographicEntryId', <any>bibliographicEntryId);
        }

        if (bibliographicResourceId !== undefined) {
            queryParameters.set('bibliographicResourceId', <any>bibliographicResourceId);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json',
            'image/png',
            'application/pdf'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * creates a bibliographic entry for the given bibliographic resource
     * @param bibliographicResourceId The _id of the bibliographic resource to which the new bibliographic entry should be appended
     * @param bibliographicEntry A bibliographic entry which should be saved
     */
    public createWithHttpInfo(bibliographicResourceId: string, bibliographicEntry: models.BibliographicEntry, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/bibliographicEntries';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'bibliographicResourceId' is not null or undefined
        if (bibliographicResourceId === null || bibliographicResourceId === undefined) {
            throw new Error('Required parameter bibliographicResourceId was null or undefined when calling create.');
        }
        // verify required parameter 'bibliographicEntry' is not null or undefined
        if (bibliographicEntry === null || bibliographicEntry === undefined) {
            throw new Error('Required parameter bibliographicEntry was null or undefined when calling create.');
        }
        if (bibliographicResourceId !== undefined) {
            queryParameters.set('bibliographicResourceId', <any>bibliographicResourceId);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json',
            'image/png',
            'application/pdf'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: bibliographicEntry == null ? '' : JSON.stringify(bibliographicEntry), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Retrieves external br suggestions for a given query string related to a bibliographic entry.
     * @param query The query string for which the suggestions shall be retrieved
     * @param threshold The sring similarity (dice coefficient) between the query string and the title + subtile + contributors above which suggestions shall be retrieved
     */
    public getExternalSuggestionsByQueryStringWithHttpInfo(query: string, threshold?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getExternalSuggestionsByQueryString';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'query' is not null or undefined
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling getExternalSuggestionsByQueryString.');
        }
        if (query !== undefined) {
            queryParameters.set('query', <any>query);
        }

        if (threshold !== undefined) {
            queryParameters.set('threshold', <any>threshold);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json',
            'image/png',
            'application/pdf'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Retrieves internal br suggestions for a given query string related to a bibliographic entry.
     * @param query The query string for which the suggestions shall be retrieved
     * @param threshold The elastic relevance score for above which entrys shall be retrieved
     */
    public getInternalSuggestionsByQueryStringWithHttpInfo(query: string, threshold?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getInternalSuggestionsByQueryString';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'query' is not null or undefined
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling getInternalSuggestionsByQueryString.');
        }
        if (query !== undefined) {
            queryParameters.set('query', <any>query);
        }

        if (threshold !== undefined) {
            queryParameters.set('threshold', <any>threshold);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json',
            'image/png',
            'application/pdf'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Retrieves the BEs that are not processed by a librarian yet.
     * @param scanId The Id of the Scan for which the BEs shall be retrieved
     */
    public getToDoBibliographicEntriesWithHttpInfo(scanId?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/getToDoBibliographicEntries';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (scanId !== undefined) {
            queryParameters.set('scanId', <any>scanId);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json',
            'image/png',
            'application/pdf'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Deletes a given bibliographic entry by id.
     * @param id The _id of the bibliographic entry to be deleted.
     */
    public removeWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/bibliographicEntries/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling remove.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json',
            'image/png',
            'application/pdf'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Given the _id of a bibliographic entry this service clears all properties related to a potential target resource in a consistent way. More precisely, the following three things happen: 1) The &#39;references&#39; property of the bibliographic entry will be cleared 2) The _id of the old target resource will be removed from teh &#39;cites&#39; property of the parent resource of the entry 3) The &#39;status&#39; of the bibliographic entry will be changed to OCR_PROCESSED --&gt; Is this always ok? Note that the old target bibliographic resource will not be deleted. 
     * @param bibliographicEntryId The _id of the subject bibliographic entry that should point to the target bibliographic resource
     */
    public removeTargetBibliographicResourceWithHttpInfo(bibliographicEntryId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/removeTargetBibliographicResource';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'bibliographicEntryId' is not null or undefined
        if (bibliographicEntryId === null || bibliographicEntryId === undefined) {
            throw new Error('Required parameter bibliographicEntryId was null or undefined when calling removeTargetBibliographicResource.');
        }
        if (bibliographicEntryId !== undefined) {
            queryParameters.set('bibliographicEntryId', <any>bibliographicEntryId);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json',
            'image/png',
            'application/pdf'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Updates a given bibliographic entry by id. Note that the status needs to be changed to VALID if this service is called after validation by a librarian. Properties that are not given with the update data are preserved.
     * @param id The _id of the bibliographic entry to be updated.
     * @param bibliographicEntry A bibliographic entry with new values to be updated.
     */
    public updateWithHttpInfo(id: string, bibliographicEntry: models.BibliographicEntry, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/bibliographicEntries/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling update.');
        }
        // verify required parameter 'bibliographicEntry' is not null or undefined
        if (bibliographicEntry === null || bibliographicEntry === undefined) {
            throw new Error('Required parameter bibliographicEntry was null or undefined when calling update.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json',
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json',
            'image/png',
            'application/pdf'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: bibliographicEntry == null ? '' : JSON.stringify(bibliographicEntry), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
